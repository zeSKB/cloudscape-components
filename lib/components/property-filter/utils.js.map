{"version":3,"file":"utils.js","sourceRoot":"lib/default/","sources":["property-filter/utils.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ComparisonOperator, InternalFilteringOption, InternalFilteringProperty, Token } from './interfaces';\n\n// Finds the longest property the filtering text starts from.\nexport function matchFilteringProperty(\n  filteringProperties: readonly InternalFilteringProperty[],\n  filteringText: string\n): null | InternalFilteringProperty {\n  let maxLength = 0;\n  let matchedProperty: null | InternalFilteringProperty = null;\n\n  for (const property of filteringProperties) {\n    if (\n      (property.propertyLabel.length >= maxLength && startsWith(filteringText, property.propertyLabel)) ||\n      (property.propertyLabel.length > maxLength &&\n        startsWith(filteringText.toLowerCase(), property.propertyLabel.toLowerCase()))\n    ) {\n      maxLength = property.propertyLabel.length;\n      matchedProperty = property;\n    }\n  }\n\n  return matchedProperty;\n}\n\n// Finds the longest operator the filtering text starts from.\nexport function matchOperator(\n  allowedOperators: readonly ComparisonOperator[],\n  filteringText: string\n): null | ComparisonOperator {\n  filteringText = filteringText.toLowerCase();\n\n  let maxLength = 0;\n  let matchedOperator: null | ComparisonOperator = null;\n\n  for (const operator of allowedOperators) {\n    if (operator.length > maxLength && startsWith(filteringText, operator.toLowerCase())) {\n      maxLength = operator.length;\n      matchedOperator = operator;\n    }\n  }\n\n  return matchedOperator;\n}\n\n// Finds if the filtering text matches any operator prefix.\nexport function matchOperatorPrefix(\n  allowedOperators: readonly ComparisonOperator[],\n  filteringText: string\n): null | string {\n  if (filteringText.trim().length === 0) {\n    return '';\n  }\n  for (const operator of allowedOperators) {\n    if (startsWith(operator.toLowerCase(), filteringText.toLowerCase())) {\n      return filteringText;\n    }\n  }\n  return null;\n}\n\nexport function matchTokenValue(token: Token, filteringOptions: readonly InternalFilteringOption[]): Token {\n  const propertyOptions = filteringOptions.filter(option => option.propertyKey === token.propertyKey);\n  const bestMatch = { ...token };\n  for (const option of propertyOptions) {\n    if ((option.label && option.label === token.value) || (!option.label && option.value === token.value)) {\n      // exact match found: return it\n      return { ...token, value: option.value };\n    }\n\n    // By default, the token value is a string, but when a custom property is used,\n    // the token value can be any, therefore we need to check for its type before calling toLowerCase()\n    if (\n      typeof token.value === 'string' &&\n      token.value.toLowerCase() === (option.label ?? option.value ?? '').toLowerCase()\n    ) {\n      // non-exact match: save and keep running in case exact match found later\n      bestMatch.value = option.value;\n    }\n  }\n\n  return bestMatch;\n}\n\nexport function getPropertyByKey(filteringProperties: readonly InternalFilteringProperty[], key: string) {\n  const propertyMap = new Map(filteringProperties.map(prop => [prop.propertyKey, prop]));\n  return propertyMap.get(key) as InternalFilteringProperty | undefined;\n}\n\nexport function getFormattedToken(filteringProperties: readonly InternalFilteringProperty[], token: Token) {\n  const property = token.propertyKey ? getPropertyByKey(filteringProperties, token.propertyKey) : undefined;\n  const valueFormatter = property?.getValueFormatter(token.operator);\n  const propertyLabel = property && property.propertyLabel;\n  const tokenValue = valueFormatter ? valueFormatter(token.value) : token.value;\n  const label = `${propertyLabel ?? ''} ${token.operator} ${tokenValue}`;\n  return { property: propertyLabel, operator: token.operator, value: tokenValue, label };\n}\n\nexport function trimStart(source: string): string {\n  let spacesLength = 0;\n  for (let i = 0; i < source.length; i++) {\n    if (source[i] === ' ') {\n      spacesLength++;\n    } else {\n      break;\n    }\n  }\n  return source.slice(spacesLength);\n}\n\nexport function trimFirstSpace(source: string): string {\n  return source[0] === ' ' ? source.slice(1) : source;\n}\n\nfunction startsWith(source: string, target: string): boolean {\n  return source.indexOf(target) === 0;\n}\n"]}