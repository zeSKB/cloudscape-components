{"version":3,"file":"use-sticky-columns.js","sourceRoot":"lib/default/","sources":["table/use-sticky-columns.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\nimport AsyncStore from '../area-chart/model/async-store';\nimport { useStableEventHandler } from '../internal/hooks/use-stable-event-handler';\nimport clsx from 'clsx';\nimport { useResizeObserver } from '../internal/hooks/container-queries';\n\n// We allow the table to have a minimum of 148px of available space besides the sum of the widths of the sticky columns\n// This value is an UX recommendation and is approximately 1/3 of our smallest breakpoint (465px)\nconst MINIMUM_SCROLLABLE_SPACE = 148;\n\ninterface StickyColumnsProps {\n  visibleColumns: readonly PropertyKey[];\n  stickyColumnsFirst: number;\n  stickyColumnsLast: number;\n}\n\nexport interface StickyColumnsModel {\n  isEnabled: boolean;\n  store: StickyColumnsStore;\n  style: {\n    wrapper?: React.CSSProperties;\n  };\n  refs: {\n    table: React.RefCallback<HTMLElement>;\n    wrapper: React.RefCallback<HTMLElement>;\n    cell: (columnId: PropertyKey, node: null | HTMLElement) => void;\n  };\n}\n\nexport interface StickyColumnsState {\n  cellState: Record<PropertyKey, null | StickyColumnsCellState>;\n  wrapperState: StickyColumnsWrapperState;\n}\n\n// Cell state is used to apply respective styles and offsets to sticky cells.\nexport interface StickyColumnsCellState {\n  padLeft: boolean;\n  lastLeft: boolean;\n  lastRight: boolean;\n  offset: { left?: number; right?: number };\n}\n\n// Scroll padding is applied to table's wrapper so that the table scrolls when focus goes behind sticky column.\nexport interface StickyColumnsWrapperState {\n  scrollPaddingLeft: number;\n  scrollPaddingRight: number;\n}\n\nexport function useStickyColumns({\n  visibleColumns,\n  stickyColumnsFirst,\n  stickyColumnsLast,\n}: StickyColumnsProps): StickyColumnsModel {\n  const store = useMemo(() => new StickyColumnsStore(), []);\n  const wrapperRef = useRef<HTMLElement>(null) as React.MutableRefObject<null | HTMLElement>;\n  const tableRef = useRef<HTMLElement>(null) as React.MutableRefObject<null | HTMLElement>;\n  const cellsRef = useRef<Record<PropertyKey, HTMLElement>>({});\n\n  const hasStickyColumns = stickyColumnsFirst + stickyColumnsLast > 0;\n\n  const updateStickyStyles = useStableEventHandler(() => {\n    if (wrapperRef.current && tableRef.current) {\n      store.updateCellStyles({\n        wrapper: wrapperRef.current,\n        table: tableRef.current,\n        cells: cellsRef.current,\n        visibleColumns,\n        stickyColumnsFirst,\n        stickyColumnsLast,\n      });\n    }\n  });\n\n  useResizeObserver(wrapperRef, updateStickyStyles);\n\n  useResizeObserver(tableRef, updateStickyStyles);\n\n  useEffect(() => {\n    if (wrapperRef.current && tableRef.current) {\n      store.updateCellStyles({\n        wrapper: wrapperRef.current,\n        table: tableRef.current,\n        cells: cellsRef.current,\n        visibleColumns,\n        stickyColumnsFirst,\n        stickyColumnsLast,\n      });\n    }\n  }, [store, stickyColumnsFirst, stickyColumnsLast, visibleColumns]);\n\n  // Update wrapper styles imperatively to avoid unnecessary re-renders.\n  useEffect(() => {\n    if (!hasStickyColumns) {\n      return;\n    }\n\n    const selector = (state: StickyColumnsState) => state.wrapperState;\n\n    const updateWrapperStyles = (state: StickyColumnsWrapperState, prev: StickyColumnsWrapperState) => {\n      if (isWrapperStatesEqual(state, prev)) {\n        return;\n      }\n\n      if (wrapperRef.current) {\n        wrapperRef.current.style.scrollPaddingLeft = state.scrollPaddingLeft + 'px';\n        wrapperRef.current.style.scrollPaddingRight = state.scrollPaddingRight + 'px';\n      }\n    };\n\n    const unsubscribe = store.subscribe(selector, (newState, prevState) =>\n      updateWrapperStyles(selector(newState), selector(prevState))\n    );\n    return unsubscribe;\n  }, [store, hasStickyColumns]);\n\n  const setWrapper = useCallback(\n    (node: null | HTMLElement) => {\n      if (wrapperRef.current) {\n        wrapperRef.current.removeEventListener('scroll', updateStickyStyles);\n      }\n      if (node && hasStickyColumns) {\n        node.addEventListener('scroll', updateStickyStyles);\n      }\n      wrapperRef.current = node;\n    },\n    [hasStickyColumns, updateStickyStyles]\n  );\n\n  const setTable = useCallback((node: null | HTMLElement) => {\n    tableRef.current = node;\n  }, []);\n\n  const setCell = useCallback((columnId: PropertyKey, node: null | HTMLElement) => {\n    if (node) {\n      cellsRef.current[columnId] = node;\n    } else {\n      delete cellsRef.current[columnId];\n    }\n  }, []);\n\n  return {\n    isEnabled: hasStickyColumns,\n    store,\n    style: {\n      // Provide wrapper styles as props so that a re-render won't cause invalidation.\n      wrapper: hasStickyColumns ? { ...store.get().wrapperState } : undefined,\n    },\n    refs: { wrapper: setWrapper, table: setTable, cell: setCell },\n  };\n}\n\ninterface UseStickyCellStylesProps {\n  stickyColumns: StickyColumnsModel;\n  columnId: PropertyKey;\n  getClassName: (styles: null | StickyColumnsCellState) => Record<string, boolean>;\n}\n\ninterface StickyCellStyles {\n  ref: React.RefCallback<HTMLElement>;\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nexport function useStickyCellStyles({\n  stickyColumns,\n  columnId,\n  getClassName,\n}: UseStickyCellStylesProps): StickyCellStyles {\n  const cellRef = useRef<HTMLElement>(null) as React.MutableRefObject<HTMLElement>;\n  const setCell = stickyColumns.refs.cell;\n  const refCallback = useCallback(\n    node => {\n      cellRef.current = node;\n      setCell(columnId, node);\n    },\n    [columnId, setCell]\n  );\n\n  // Update cell styles imperatively to avoid unnecessary re-renders.\n  useEffect(\n    () => {\n      if (!stickyColumns.isEnabled) {\n        return;\n      }\n\n      const selector = (state: StickyColumnsState) => state.cellState[columnId];\n\n      const updateCellStyles = (state: null | StickyColumnsCellState, prev: null | StickyColumnsCellState) => {\n        if (isCellStatesEqual(state, prev)) {\n          return;\n        }\n\n        const className = getClassName(state);\n        const cellElement = cellRef.current;\n        if (cellElement) {\n          Object.keys(className).forEach(key => {\n            if (className[key]) {\n              cellElement.classList.add(key);\n            } else {\n              cellElement.classList.remove(key);\n            }\n          });\n          cellElement.style.left = state?.offset.left !== undefined ? `${state.offset.left}px` : '';\n          cellElement.style.right = state?.offset.right !== undefined ? `${state.offset.right}px` : '';\n        }\n      };\n\n      const unsubscribe = stickyColumns.store.subscribe(selector, (newState, prevState) =>\n        updateCellStyles(selector(newState), selector(prevState))\n      );\n      return () => {\n        unsubscribe();\n        // Force the cleanup\n        updateCellStyles(null, { padLeft: false, lastLeft: false, lastRight: false, offset: {} });\n      };\n    },\n    // getClassName is expected to be pure\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [stickyColumns.store, stickyColumns.isEnabled, columnId]\n  );\n\n  // Provide cell styles as props so that a re-render won't cause invalidation.\n  const cellStyles = stickyColumns.store.get().cellState[columnId];\n  return {\n    ref: refCallback,\n    className: cellStyles ? clsx(getClassName(cellStyles)) : undefined,\n    style: cellStyles?.offset ?? undefined,\n  };\n}\n\nfunction isCellStatesEqual(s1: null | StickyColumnsCellState, s2: null | StickyColumnsCellState): boolean {\n  if (s1 && s2) {\n    return (\n      s1.padLeft === s2.padLeft &&\n      s1.lastLeft === s2.lastLeft &&\n      s1.lastRight === s2.lastRight &&\n      s1.offset.left === s2.offset.left &&\n      s1.offset.right === s2.offset.right\n    );\n  }\n  return s1 === s2;\n}\n\nfunction isWrapperStatesEqual(s1: StickyColumnsWrapperState, s2: StickyColumnsWrapperState): boolean {\n  return s1.scrollPaddingLeft === s2.scrollPaddingLeft && s1.scrollPaddingRight === s2.scrollPaddingRight;\n}\n\ninterface UpdateCellStylesProps {\n  wrapper: HTMLElement;\n  table: HTMLElement;\n  cells: Record<PropertyKey, HTMLElement>;\n  visibleColumns: readonly PropertyKey[];\n  stickyColumnsFirst: number;\n  stickyColumnsLast: number;\n}\n\nexport default class StickyColumnsStore extends AsyncStore<StickyColumnsState> {\n  private cellOffsets = new Map<PropertyKey, { first: number; last: number }>();\n  private stickyWidthLeft = 0;\n  private stickyWidthRight = 0;\n  private isStuckToTheLeft = false;\n  private isStuckToTheRight = false;\n  private padLeft = false;\n\n  constructor() {\n    super({ cellState: {}, wrapperState: { scrollPaddingLeft: 0, scrollPaddingRight: 0 } });\n  }\n\n  public updateCellStyles(props: UpdateCellStylesProps) {\n    const hasStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast > 0;\n    const hadStickyColumns = this.cellOffsets.size > 0;\n\n    if (hasStickyColumns || hadStickyColumns) {\n      this.updateScroll(props);\n      this.updateCellOffsets(props);\n      this.set(() => ({\n        cellState: this.generateCellStyles(props),\n        wrapperState: { scrollPaddingLeft: this.stickyWidthLeft, scrollPaddingRight: this.stickyWidthRight },\n      }));\n    }\n  }\n\n  private updateScroll(props: UpdateCellStylesProps) {\n    const wrapperScrollLeft = props.wrapper.scrollLeft;\n    const wrapperScrollWidth = props.wrapper.scrollWidth;\n    const wrapperClientWidth = props.wrapper.clientWidth;\n    const tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;\n    const tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;\n\n    this.isStuckToTheLeft = wrapperScrollLeft > tablePaddingLeft;\n\n    // Math.ceil() is used here to address an edge-case in certain browsers, where they return non-integer wrapperScrollLeft values\n    // which are lower than expected (sub-pixel difference), resulting in the table always being in the \"stuck to the right\" state\n    this.isStuckToTheRight = Math.ceil(wrapperScrollLeft) < wrapperScrollWidth - wrapperClientWidth - tablePaddingRight;\n\n    this.padLeft = tablePaddingLeft !== 0 && this.isStuckToTheLeft;\n  }\n\n  private generateCellStyles = (props: UpdateCellStylesProps): Record<PropertyKey, null | StickyColumnsCellState> => {\n    const isEnabled = this.isEnabled(props);\n    const lastLeftStickyColumnIndex = props.stickyColumnsFirst - 1;\n    const lastRightStickyColumnIndex = props.visibleColumns.length - props.stickyColumnsLast;\n\n    return props.visibleColumns.reduce((acc, columnId, index) => {\n      let stickySide = 'non-sticky';\n      if (index < props.stickyColumnsFirst) {\n        stickySide = 'left';\n      } else if (index >= props.visibleColumns.length - props.stickyColumnsLast) {\n        stickySide = 'right';\n      }\n\n      if (!isEnabled || stickySide === 'non-sticky') {\n        acc[columnId] = null;\n        return acc;\n      }\n\n      // Determine the offset of the sticky column using the `cellOffsets` state object\n      const isFirstColumn = index === 0;\n      const stickyColumnOffsetLeft = this.cellOffsets.get(columnId)?.first ?? 0;\n      const stickyColumnOffsetRight = this.cellOffsets.get(columnId)?.last ?? 0;\n\n      acc[columnId] = {\n        padLeft: isFirstColumn && this.padLeft,\n        lastLeft: this.isStuckToTheLeft && lastLeftStickyColumnIndex === index,\n        lastRight: this.isStuckToTheRight && lastRightStickyColumnIndex === index,\n        offset: {\n          left: stickySide === 'left' ? stickyColumnOffsetLeft : undefined,\n          right: stickySide === 'right' ? stickyColumnOffsetRight : undefined,\n        },\n      };\n      return acc;\n    }, {} as Record<PropertyKey, null | StickyColumnsCellState>);\n  };\n\n  private updateCellOffsets = (props: UpdateCellStylesProps): void => {\n    const firstColumnsWidths: number[] = [];\n    for (let i = 0; i < props.visibleColumns.length; i++) {\n      const element = props.cells[props.visibleColumns[i]];\n      const cellWidth = element.getBoundingClientRect().width ?? 0;\n      firstColumnsWidths[i] = (firstColumnsWidths[i - 1] ?? 0) + cellWidth;\n    }\n\n    const lastColumnsWidths: number[] = [];\n    for (let i = props.visibleColumns.length - 1; i >= 0; i--) {\n      const element = props.cells[props.visibleColumns[i]];\n      const cellWidth = element.getBoundingClientRect().width ?? 0;\n      lastColumnsWidths[i] = (lastColumnsWidths[i + 1] ?? 0) + cellWidth;\n    }\n    lastColumnsWidths.reverse();\n\n    this.stickyWidthLeft = firstColumnsWidths[props.stickyColumnsFirst - 1] ?? 0;\n    this.stickyWidthRight = lastColumnsWidths[props.stickyColumnsLast - 1] ?? 0;\n    this.cellOffsets = props.visibleColumns.reduce(\n      (map, columnId, columnIndex) =>\n        map.set(columnId, {\n          first: firstColumnsWidths[columnIndex - 1] ?? 0,\n          last: lastColumnsWidths[props.visibleColumns.length - 1 - columnIndex - 1] ?? 0,\n        }),\n      new Map()\n    );\n  };\n\n  private isEnabled = (props: UpdateCellStylesProps): boolean => {\n    const noStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast === 0;\n    if (noStickyColumns) {\n      return false;\n    }\n\n    const wrapperWidth = props.wrapper.getBoundingClientRect().width;\n    const tableWidth = props.table.getBoundingClientRect().width;\n    const isWrapperScrollable = tableWidth > wrapperWidth;\n    if (!isWrapperScrollable) {\n      return false;\n    }\n\n    const totalStickySpace = this.stickyWidthLeft + this.stickyWidthRight;\n    const tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;\n    const tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;\n    const hasEnoughScrollableSpace =\n      totalStickySpace + MINIMUM_SCROLLABLE_SPACE + tablePaddingLeft + tablePaddingRight < wrapperWidth;\n    if (!hasEnoughScrollableSpace) {\n      return false;\n    }\n\n    return true;\n  };\n}\n"]}